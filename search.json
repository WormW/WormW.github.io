[{"title":"多集群与多租户","url":"/2022/06/28/多集群与多租户/"},{"title":"裁经Day2","url":"/2022/06/28/裁经Day2/","content":"1. 距离去申请仲裁立案过去了不到一周，接到了仲裁院的电话，通知我2周后进行案前调解\n2. 整个流程比我想象中快\n","tags":["仲裁"]},{"title":"微服务学习笔记-gRPC与服务发现","url":"/2022/06/28/微服务学习笔记-gRPC与服务发现/","content":"\n1. gRPC\n   \n   1. 特点\n   \n      1. 多语言：语言中立\n      2. 轻量级、高性能：序列化支持Protocol Buffer和JSON\n      3. 可插拔\n      4. IDL：基于文件定义服务，通过proto3工具生成指定语言的数据结构、服务端接口以及客户端Stub\n      5. 设计理念\n      6. 移动端：基于http/2设计，支持双向流、消息头压缩、单TCP的多路复用、服务端推送等特性\n      7. 服务而非对象、消息而非饮用：微服务间粗粒度消息交互\n      8. 负载无关\n      9. 流：streaming api\n      10. 阻塞式和非阻塞式\n      11. 元数据交流\n      12. 标准化状态码\n   \n   2. 先做标准化，再考虑性能\n   \n   3. HealthCheck 标准的健康监测协议\n   \n      1. 用于外挂的容器健康监测或者流量监测（readiness liveness）\n      2. 平滑发布\n         1. k8s 向discovery发起注销\n         2. k8s 向app发送sigterm\n         3. 最长两个心跳骤起内退出\n         4. k8s退出超时 sigkil\n   \n1. 服务发现\n   \n      1. 客户端发现\n         1. 直连\n         2. 少一次网络跳转\n         3. 需要客户端实现知道服务发现和转发逻辑\n      \n      2. 服务端发现（服务实例在服务注册表上被注册和注销）\n         1. 多一次网络跳转\n         2. 性能有所损失\n      \n      3. 微服务核心是去中心化，使用客户端发现模式\n      4. zookeeper、eureka\n      5. 自保护机制\n      6. 心跳机制\n      7. 少量节点负责写，大量节点负责读的模式（Eureka2.0）\n\n","tags":["微服务"]},{"title":"微服务学习笔记-微服务设计","url":"/2022/06/28/微服务学习笔记-微服务设计/","content":"1. API Gateway\n   1. 直接暴露微服务问题\n      1. 如果没有统一网关，会导致无法下掉老旧接口\n      2. 客户端到微服务强耦合\n      3. 多次请求，客户端聚合数据，工作量大，延迟高（影响客户端交付速度）\n      4. 把对接复杂度聚焦于端\n      5. 适配复杂度下移到微服务本身了\n   2. 解决方案app-interface（BFF）\n      1. 胶水层负责组装数据\n      2. 轻量交互，协议精简、聚合\n      3. 差异服务，数据裁剪以及聚合、针对终端定制API\n      4. 动态升级\n      5. 沟通效率提高\n   3. BFF属于 single point of failure，严重代码缺陷或者流量洪峰可能引发集群宕机\n      1. 拆分BFF，到具体模块\n      2. 升级框架中间件变困难\n      3. 跨横切面cross-cutting concerns 直接继续继续分层\n         1. 中间件功能使用api-gateway\n   4. 流量流向 端->api gateway -> bff -> microservice\n2. 微服务划分\n   1. 业务职能\n   2. DDD的限界上下文bounded context\n      1. 业务边界抽象\n      2. 抽象业务域\n3. CQRS\n   1. 命令端和查询端解耦\n   2. canal->kafka->清洗数据后将数据写入查询用库\n4. api-gateway负责统一鉴权\n5. 服务内部区分身份认证和授权（***RBAC***）\n   1. full trust\n   2. half trust\n   3. zero trust\n6. RPC鉴权\n   1. 证书\n   2. token","tags":["微服务"]},{"title":"微服务学习笔记-微服务概览","url":"/2022/06/27/微服务学习笔记-微服务概览/","content":"\n1. 微服务发展历程\n2. 单体架构\n   1. 使用模块化逻辑划分\n   2. 最终打包成大型单体\n   3. 化繁为简分而治之\n3. 微服务起源\n   1. 特点\n      1. SOA面向服务的架构模式\n      2. **小即是美**\n      3. **单一指责**\n      4. **尽可能早地创建原型**\n      5. **可移植性比效率更重要**\n   2. 运维和开发本质上对于上线是有冲突的，运维需要保持尽量的稳定，开发需要尽快的上线，对于单体架构存在更大的冲突，上线日会造成比较大的麻烦\n   3. 要具备通信的通用性\n   4. 定义\n      1. 原子服务（拆分了DB增加了系统的整体吞吐性能）\n      2. 独立进程\n      3. 隔离部署（一个物理机也可以部署多个隔离pod）（对部署多个微服务 降低crash影响）\n      4. 去中心化服务治理\n      5. 基础设施建设、复杂度高（缺点）\n   5. 不足\n      1. 增加了固有的复杂性，需要处理服务不可用和服务传递速度慢的问题\n      2. 分布式事务\n      3. 测试单一应用变复杂\n      4. 服务见的依赖，导致单一应用影响多个服务\n      5. 运维基础设施挑战高\n4. 组件服务化（多个微服务组成一个usercase）\n   1. kit:需要一套微服务基础库（框架内包）\n   2. service: 由 业务代码+kit+第三方依赖组成\n   3. RPC + message queue：轻量级通讯 \n5. 去中心化\n   1. 数据去中心化（缓存数据隔离）\n   2. 治理去中心化（避免中心热点）\n   3. 技术去中心化（不绑定语言）\n6. 基础设施自动化\n   1. cicd：gitlab +gitlab hooks +kubernetes\n   2. Testing：测试环境、单元测试、API自动化测试\n   3. 在线运行时：kubernetes，以及一系列prometheus、ELK、control panel\n7. 可用性&兼容性设计\n   1. Design For Failure\n   2. 隔离\n   3. 超时控制\n   4. 负载保护\n   5. 限流\n   6. 降级\n   7. 重试\n   8. 负载均衡\n8. 发送时保守，接受时开放【伯斯塔尔法则】尽量少传数据，接收时可以接受冗余\n","tags":["微服务"]},{"title":"goroutine与promise","url":"/2022/06/27/goroutine与promise/","content":"1. 看上去goroutine和promise有点像，但是实际上是不一样的。\n\nGolang:\n\n```go\nfunc main() {\n   go func() {\n      fmt.Println(\"aaa\")\n      time.Sleep(time.Second * 5)\n      fmt.Println(\"ccc\")\n   }()\n   fmt.Println(\"bbb\")\n   time.Sleep(time.Second * 2)\n}\n```\n\n这段代码执行的结果是 bbb aaa\n\nNodeJS:\n\n```js\nasync function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function main() {\n    new Promise(async function (resolve, reject) {\n        console.log(\"aaa\")\n\n        await sleep(1000)\n        console.log(\"ccc\")\n    })\n    console.log(\"bbb\")\n    await sleep(2000)\n    console.log(\"eee\")\n}\n\nmain()\n```\n\n执行结果是aaa bbb ccc eee\n\n执行切换上下文的节点不一样，promise回立刻执行，goroutine不会","tags":["Golang","NodeJS"]},{"title":"排序基础","url":"/2022/06/26/排序基础/","content":"1. 快速排序\n   1. 基准数左右分堆交换\n   2. 再次对左右堆进行分堆交换\n   3. 直至堆内不发生变动\n2. 冒泡排序\n   1. 交换相邻\n   2. 重复交换相邻过程\n   3. 直至再不发生变化\n3. 插入排序\n   1. 认为第一个元素有序\n   2. 遍历之后的每个元素从尾交换他们的位置，直至交换到第一个元素\n4. ","tags":["面试","排序"]},{"title":"GoLang基础","url":"/2022/06/25/GoLang基础/","content":"\n1. rune是别称类型，int32\n2. byte是别称类型，uint8\n2. 切片翻倍扩容\n2. 子切片发生扩容后不再与原数组共享内存\n2. switch不需要break\n6. http库\n   1. body只能读一次\n   2. getBody可以读多次，但是原生的http.Request是nil\n   3. header会自动转换大小写\n   4. form要先parseForm\n7.  var _ Interface = &struct{} （确保结构体实现了接口\n8. interface代表一种约束，可以作为参数传递\n9. struct作为一种实体，比较类似class的感觉，作为真正的方法的调用方，二者通过返回值串联，或者通过7约束\n10. builtin是属于全局内建\n11. error.Is会层层解包最终返回\n12. error.As转换包判断能否相等（会进行类型转换尝试）\n12. defer由下至上执行->类似栈，先进后出\n12. 闭包：函数匿名+定义他的上下文，可以访问定义范围外的变量，闭包延时绑定（最终执行的时候的变量才是延迟执行的）\n12. panic代表无可挽回，可以用recover恢复\n12. channel 缓存满了阻塞生产者，缓存空了阻塞消费者\n17. golang里面更重要的是接口的抽象和使用func传递的设计感觉\n    1. 比如设计可扩展的中间件，过滤器\n    2. 会涉及到传入类似callback的东西去处理","tags":["golang","基础"]},{"title":"网络协议复习-HTTP","url":"/2022/06/24/网络协议复习-HTTP/","content":"\n# HTTP\n\n1. 基于TCP\n2. 2.0版本对包头进行压缩\n   1. 1.1多请求串行\n   2. 2.0请求并行\n3. keep-alive 保持连接不会立刻中断tcp连接，请求复用\n\n# HTTPS\n\n1. https的通信流程是为了通过非对称加密来生成对称加密使用的参数\n2. 流程\n   1. 客户端生成随机数\n   2. 服务端返回随机数\n   3. 审核服务端证书\n   4. 审核客户端证书\n   5. 生成pre-master\n   6. 服务端+客户端+pre-master 算出对称密钥\n   7. 测试参数- c->s\n   8. 测试参数- s->c\n   9. 完成\n3. 包内包含时间戳和随机数，确保不会被重放和篡改\n4. SSL在应用层和传输层之间\n\n\n\n# QUIC\n\n1. HTTP3.0\n2. 基于udp\n3. 自定义连接机制\n4. 自定义重传机制\n5. 无阻塞的多路复用\n6. 自定义流量控制\n","tags":["HTTP","HTTPS","QUIC"]},{"title":"网络协议复习-TCP与UDP","url":"/2022/06/24/网络协议复习-TCP与UDP/","content":"\n1. TCP\n   1. 超时重试\n      1. 根据往返时间RTT计算超时重试时间-自适应重传算法\n      2. 超时一次时间加倍一次\n      3. SACK 选择应答 TCP包头增加SACK ，接收端返回三个重复的ack，发送方立刻重发丢失包\n   2. 流量控制\n      1. 滑动窗口\n         1. 避免包堆积\n         2. 接收方处理不过来时发送方不再发送\n         3. 发送方发送窗口探测数据包 调整窗口大小\n      2. 拥塞控制\n         1. TCP BBR拥塞算法，寻找最大，但不占用缓存的发送速度\n         2. 传统算法在速度达到最大值时会因为中间设备缓存问题导致时延变大\n   3. 特点\n      1. 可靠交付\n      2. 面向字节流\n      3. 拥塞控制\n      4. 有状态服务\n2. UDP\n   1. 结构简单\n   2. 不建立连接\n   3. 不做拥塞控制\n   4. 适合做广播\n   5. 应用\n      - 将能力返还给应用层，应用决定具体实现不拘泥于传统的拥塞控制\n      - DHCP、VXLAN、QUIC\n3. Socket\n   1. tcp理论上限 客户端ip x 客户端端口=2^32*2^16=2^48\n   2. 实际上收到**文件描述符**限制和**内存**限制 达不到上限\n   3. 增加接受能力方式\n      1. 多进程- fork进程\n      2. 多线程- pthread_create\n      3. IO多路复用，一个线程维护多个Socket\n         1. fd_set\n         2. select函数，轮训\n      4. IO多路复用\n         1. epoll callback通知（解决c10k）\n\n","tags":["面试","复习","网络协议"]},{"title":"面试PHP-Day1","url":"/2022/06/24/面试PHP-Day1/","content":"\n太久没面试了，记录一下找感觉的过程，和面试过程中遇到的问题\n\n## 问题\n\n1. 网络分层\n   1. OSI七层模型（由上至下 外到底）\n      1. 应用层\n      2. 表示层\n      3. 会话层\n      4. 传输层\n      5. 网络层\n      6. 数据链路层\n      7. 物理层\n   2. TCP/IP四层模型\n      1. 应用层(1.1 1.2 1.3)\n      2. 传输层 \n      3. 网络层 1.5\n      4. 网络接口层（1.6 1.7）\n2. TCP三次握手四次挥手\n   1. 三次握手（证明有来有回，连通性）\n      1. 请求（syn,自身变为syn_sent）\n      2. 应答（syn,自身从listen 变为 syn_rcvd）\n      3. 应答的应答（ack,自身变为established，对方收到后一样）\n   2. 四次挥手\n      1. a：fin(要断开) （变为FIN_WAIT_1）\n      2. b：返回ack（变为CLOSED_WAIT）\n      3. b：返回fin,ack(准备完成)，变为LAST_ACK\n      4. a：返回ack 变为 TIME_WAIT，等待2MSL（为了保证b能收到最后的ack）\n      5. TIME_WAIT这个问的我直接失忆了...太久没看这些了\n3. php-fpm 运行模式\n   1. Static 直接fork max_children\n   2. dynamic 动态fork worker（保证最小）\n   3. ondemand（初始不分配worker，最大max_children 空闲process_idle_timeout后推出）\n\n### tips\n\n答得还可以的问题或者我觉得有思路的问题就不写了\n","tags":["面试","PHP"]},{"title":"裁经Day1","url":"/2022/06/24/裁经Day1/","content":"\n## 介绍\n\n1. 仲裁院只负责经济纠纷，不负责离职证明\n2. 仲裁需要去注册地的仲裁院\n3. 离职证明需要去工作地的劳动监察大队（可以扫码直接网上申请）\n4. 海淀区有两个仲裁院（海淀仲裁院和中关村分院）\n   1. 2022.06这个时间节点，中关村分院也可以受理海淀非中关村区域的仲裁申请\n   2. 中关村分院不需要排队\n   3. 海淀分院八点之前就已经差不多排满上午的号了\n\n## 经历\n\n1. 我是去的海淀仲裁院，所以以下内容只针对海淀分院\n   1. 只需要知道公司的地址公司的名称即可\n   2. 需要带劳动合同和身份证\n   3. 第一次去只是提交申请，不需要提交证据\n   4. 身份证复印件窗口可以免费复印，但是会问你带没带，我没带小姐姐直接免费给我印了。\n   5. 填写完会给告知书，虽然上面写着5天内，但是小姐姐说是1-2周内练习\n   6. 排在我后面的大叔说去年他来的时候不需要排队直接取号就办理\n      1. 去年他总共耗时2个月左右但是因为强制执行的问题总共耗时8-9个月\n2. 早上赶了首班车地铁，浑浑噩噩一整天，六点多就到了仲裁院门口，八点半左右开始叫号，不到9点，办完了就出来了。\n","tags":["仲裁"]},{"title":"Hello World","url":"/2022/06/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]