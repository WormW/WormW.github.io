[{"title":"GoLang基础-Context","url":"/2022/06/30/GoLang基础-Context/","content":"\n1. context比较类似请求级别的全局变量\n2. 通过单一context可以控制和这次请求有关系的相关goroutine，可以通过done的方式去控制这个树状结构的（超时处理和取消）fail fast\n3. 和PHP的不同在于PHP的全局变量是请求独占的，但是golang是运行级别的全局变量，所以无法做到像PHP那样的直接使用，虽然可以做到类似效果的注册，但是实现成本很高\n4. go1.7后引入context包\n5. 只将和请求有关系的东西挂到context上（请求级别）\n6. withContext不建议挂载太多，会导致链路过长\n7. map比链表的优势避免了层级间的污染\n8. 可以把链路追踪，日志记录，API重要性，请求染色等内容放到context上\n9. 不要去修改context里的值，会造成data race\n10. 使用withCancel withDeadline withTimeout withValue 去替换context\n11. Done之后会层层递归 给child里的done chan 来取消掉链路上的goroutine\n12. 一定要defer cancel()\n13. rpc设计时要考虑context，考虑到上游直接取消下游的调用\n14. context被取消后，所有他的衍生context都会被取消\n15. 使用context value的时候可以定义私有类型来保证和别人不冲突\n","tags":["golang","基础"]},{"title":"GoLang基础-Channel","url":"/2022/06/30/GoLang基础-Channel/","content":"\n1. channel是类型安全的消息队列\n2. 无缓冲通道保证同步，会双向阻塞\n   1. receive先于send发生\n   2. 本质上会有比较多的goroutine唤醒\n3. 有缓冲通道在缓存满之前，可以直接继续执行，满了之后才会阻塞\n   1. send先于receive发生\n   2. buffer再达到某个值之前是越大越好的，但并不能无限制变大\n4. cancellation\n   1. close先于receive发生（类似buffered）\n5. fan in ,fan out\n6. pipeline\n7. chan关闭后还是可以接收数据\n8. chan主要是用于任务分发或者全局统一的流式处理，比如全局日志写入，类似pipeline的效果\n\n","tags":["golang","基础"]},{"title":"GoLang基础-Sync","url":"/2022/06/30/GoLang基础-Sync/","content":"\n1. 使用锁保护happens before需要使用锁保护\n\n2. 尽量使用chan通信（但是chan底层也是通过互斥锁实现，只是更加简洁）\n\n3. data race\n\n   1. go build -race\n   2. 多个goroutine共享全局变量时会出现的问题\n   3. data race的判断要根据 原子性 和 可见性\n\n4. interface底层时2个machine word\n\n5. map是原子赋值，但是也存在data race\n\n6. **`atomic.Value`**可以解决赋值的多步骤问题，本质上是通过将两步赋值拆开，检查第二步的赋值结果来验证赋值成功，在成功前不返回结果，隐藏中间态\n\n7. 也可以使用RWMutex锁，读多写少时 atomic.value效率会高很多\n\n8. copy on write-不修改老对象，复制新对象，然后修改，最后替换\n\n9. Mutex锁实现\n\n   1. barging ，锁释放后会唤醒第一个等待者，但是拿到锁的人可能是第一个等待着或者第一个请求者\n   2. handsoff，等待等待者被唤醒后交接锁，释放锁的实际会更晚，降低了吞吐量\n   3. spinning，自选锁的等待着会一直循环查询，而不会进入parking状态，也不会有被唤醒的过程\n   4. go1.8中使用barging和spining结合地方方式，试图获取已经被持有的锁事，如果本地队列位空并且P的数量大于1，goroutine会自旋几次（用一个P旋转会阻塞程序），尝试几次后进入park状态（用cpu换时间）\n   5. go1.9中增加了饥饿模式，释放时会触发handoff，将等待超过1ms的goroutine（有界等待）标记为饥饿，unlock方法会handoff把锁交给第一个等待者，饥饿模式下自旋会被停用，因为传入goroutines没有机会获取下一个等待着保留的锁（自旋一直在抢占锁）\n\n10. errgroup原理，底层通过waitgroup实现，\n\n    1. 主要是取出了waitgroup中没有拿到的错误值\n\n    2. 返回错误值之后，会填充到结构体的err属性里，可以通过wait获取\n\n    3. 通过sem 这个chan进行限流\n\n    4. 具体的内部实现在Go函数/TryGo函数\n\n       1. go会直接往sem里塞入（无返回值）/TryGo会（有返回值）如果超过限流直接返回false\n       2. 内部使用wg.Add wg.Done控制状态\n       3. 使用errOnce.Do做一个原子执行，内部使用atomic实现\n       4. 只有第一次报错的goroutine可以调用成功\n    \n11. sync.Pool\n\n    1. pool内的东西可能会被随时回收，所以不能放状态的连接\n\n    2. 应该尽量放入无状态数据\n\n    3. go1.13引入了victim cache，会将pool内数据拷贝一份，避免gc晴空，即使没有饮用的内容也可以保留最多两轮GC\n\n    4. 使用pool减少重复构建某些重用结构体\n\n       1. 具体使用gin的coutext\n\n          1. ```\n             pool.Get().(*Context)\n             ```\n\n       2. fmt.printf newPrinter\n","tags":["golang","基础"]},{"title":"GoLang基础-内存模型","url":"/2022/06/29/GoLang基础-内存模型/","content":"\n1. 为了保证goroutine读取串行化，需要使用channel或者同步原语，比如sync或者sync/atomic，mutex\n2. happen-before\n   1. 同一个goroutine中的读写顺序是按照程序中的顺序执行的\n   2. 不同goroutine中的可能看到不同的执行顺序 \n   3. 内存重排 memory recordering\n   4. 抚平内核内存硬盘之间的宿绿茶 l1 l2 l3 cache store buffer\n   5. 由于store buffer（类似数据还在缓存，没能读到，直接从memory里读取）\n   6. 通过barrier或者fence 指令 保证类似锁的机制\n   7. 单个goroutine中没有并发\n   8. 变量v的零值初始化在内存模型中表现的与写操作相同\n   9. 对大于single machine word的变量的读写操作表现的像以不确定顺序对多个single machine word的变量的操作\n   10. sync.Once是一种全局的类似singleflight的机制，但是singleflight的粒度更低，通过key去控制调用的请求\n   11. 需要用锁的机制保证先行发生，即按照正确的语义去控制变量的写\n   12. 在goroutine的嵌套中对于非原子化的赋值要慎重（主要针对goroutine共享变量或者潜逃goroutine），可能会导致取值异常\n3. 谨慎使用并发共享数据，尽量通过channel或者原子加锁对超过single machine word的赋值处理\n\n","tags":["golang","基础","内存模型","memory model"]},{"title":"GoLang基础-并发编程","url":"/2022/06/29/GoLang基础-并发编程/","content":"\n1. 并发编程\n   1. channel\n   2. goroutine\n2. 进程和线程\n   1. 进程从一个线程开始（主线程）\n   2. 主线程可以启动更多的线程\n   3. 线程可以启动更多的线程\n3. goroutines和并行编程\n   1. 并发不是并行 concurrency is not parallelism\n   2. 在不同逻辑处理器上运行，才是并行\n   3. runtime.GOMAXPROCS\n4. 如果你的goroutine在从另一个goroutine获得结果前无法取得进展，那么自己去做比用go func更简单\n5. 坏的操作 需要等待goroutine返回其启动器所需的大量状态跟踪和chan操作\n6. listDirectory如果返回channel的话回导致无法关闭，并且channel具备了二义性\n7. listDirectory(dir string,fn func(string))\n8. 将异步执行函数的决定权交给该函数的调用方\n9. 内部不要随便隐藏goroutine\n10. goroutine内使用chan要慎重，可能会导致卡住泄漏\n11. chan的阻塞可能会导致泄漏\n12. 使用goroutine前，确定 如何结束 还有什么时候结束\n13. 场景：启动两个server\n    1.  log.Fatal 调用了os.exit不建议使用\n    2. 解决：\n       1. 传入stop用chan 用来处理失败后逻辑\n       2. done负责开始监听stop\n       3. 监听到stop后关闭stop\n       4. 然后chan对应执行stop后逻辑\n14. 使用errgroup进行生命周期的管理+function optionals 进行开发\n15. 将启动goroutine的权利交给外部，内部尽量去通过chan处理内部间的逻辑\n16. 将关闭chan交给拥有者，确保没人写再关闭\n","tags":["golang","基础","goroutine"]},{"title":"GoLang基础-异常处理","url":"/2022/06/28/GoLang基础-异常处理/","content":"1. Error\n   1. Errors.New返回的是内存地址，为了避免直接比较时出现值的相等\n   2. 其他语言的异常还是处理机制，还是向上继续抛出\n   3. golang的panic是真正的中断\n   4. 不要滥用二义性\n   5. 不要滥用panic 与recover\n   6. 不需要区分error和exception的语义了【很好\n   7. Error are values\n2. 异常类型\n   1. 预定义的特定错误，sentinel error 哨兵错误\n      1. 不灵活的错误处理策略\n      2. 不依赖检查error.Error的输出，不要使用Error的值作为方法判定，只做日志\n      3. 增加API的公共部分，要暴露错误\n      4. 在两个包之间创建了依赖（错误之间的依赖）\n      5. 结论：尽可能避免sentinel error\n   2. Error types 自定义error\n      1. os.PathError\n      2. 需要使用switch 和类型断言(.(type))\n      3. 会导致自己的异常变为public，和调用者产生强耦合\n   3. Opaque errors 不透明错误\n      1. 对于不关心细节的调用方直接返回error\n      2. 对于需要细节的调用方，使用暴露函数进行类型转换判定返回细节\n   4. Wrap Error\n      1. 错误原则\n         1. 日志记录与错误无关且对调试没有帮助的信息被视为噪音\n         2. 错误要被日志记录\n         3. 应用程序处理错误，保证100%完整性\n         4. 之后不再报告当前错误\n      2. 错误处理\n         1. 和其他库协作时考虑errors.Wrap或者errors.Wrapf\n         2. 直接返回错误，不要每个地方都打日志\n         3. 程序的顶部或者goroutine顶部 %+v 记录日志\n         4. errors.Cause获取root error 再和sentinel error\n         5. 业务应该wrap，但是基础库不应该wrap\n         6. 处理不了的错误带上足够的信息向上返回\n         7. 已经处理过的错误（降级处理），不应该继续向上抛出\n3. 异常处理 handling error\n   1. 结构体包装错误和主流程（减少err!=nil）\n   2. fmt.Errorf二次包装error（sentinel errors或者type assertions（error types的类型断言）不兼容 ）\n   3. 错误只处理一次\n4. Unwrap递归寻找最终的底层error\n   1. errors.Is\n   2. errors.As\n   3. 也可以通过自定义实现Is判定\n\n5. fmt.Errorf %w 包装错误\n6. pkg errors的优势还是堆栈信息的保留\n\n","tags":["golang","基础"]},{"title":"微服务学习笔记-多集群与多租户","url":"/2022/06/28/微服务学习笔记-多集群与多租户/","content":"\n1. 多集群\n\n   1. L0服务 冗余节点\n   2. 解决单一集群的故障问题\n   3. paas平台注入到cluster中（比如cache完全独立）\n   4. 不使用业务隔离cluster，业务隔离会增加缓存击穿的概率\n   5. subset算法（节点多时）\n\n2. 多租户\n\n   1. 染色发布\n      1. 流量路由\n      2. 隔离性\n      3. 通过context带metadata传递\n\n   2. ivydad的模式本身有点像是多租户通过转发到中央网关替换host为分支地址去从网关获取，没有货渠道的直接回源到主线\n\n   \n","tags":["微服务"]},{"title":"裁经Day2","url":"/2022/06/28/裁经Day2/","content":"1. 距离去申请仲裁立案过去了不到一周，接到了仲裁院的电话，通知我2周后进行案前调解\n2. 整个流程比我想象中快\n","tags":["仲裁"]},{"title":"微服务学习笔记-gRPC与服务发现","url":"/2022/06/28/微服务学习笔记-gRPC与服务发现/","content":"\n1. gRPC\n   \n   1. 特点\n   \n      1. 多语言：语言中立\n      2. 轻量级、高性能：序列化支持Protocol Buffer和JSON\n      3. 可插拔\n      4. IDL：基于文件定义服务，通过proto3工具生成指定语言的数据结构、服务端接口以及客户端Stub\n      5. 设计理念\n      6. 移动端：基于http/2设计，支持双向流、消息头压缩、单TCP的多路复用、服务端推送等特性\n      7. 服务而非对象、消息而非饮用：微服务间粗粒度消息交互\n      8. 负载无关\n      9. 流：streaming api\n      10. 阻塞式和非阻塞式\n      11. 元数据交流\n      12. 标准化状态码\n   \n   2. 先做标准化，再考虑性能\n   \n   3. HealthCheck 标准的健康监测协议\n   \n      1. 用于外挂的容器健康监测或者流量监测（readiness liveness）\n      2. 平滑发布\n         1. k8s 向discovery发起注销\n         2. k8s 向app发送sigterm\n         3. 最长两个心跳骤起内退出\n         4. k8s退出超时 sigkil\n   \n1. 服务发现\n   \n      1. 客户端发现\n         1. 直连\n         2. 少一次网络跳转\n         3. 需要客户端实现知道服务发现和转发逻辑\n      \n      2. 服务端发现（服务实例在服务注册表上被注册和注销）\n         1. 多一次网络跳转\n         2. 性能有所损失\n      \n      3. 微服务核心是去中心化，使用客户端发现模式\n      4. zookeeper、eureka\n      5. 自保护机制\n      6. 心跳机制\n      7. 少量节点负责写，大量节点负责读的模式（Eureka2.0）\n\n","tags":["微服务"]},{"title":"微服务学习笔记-微服务设计","url":"/2022/06/28/微服务学习笔记-微服务设计/","content":"1. API Gateway\n   1. 直接暴露微服务问题\n      1. 如果没有统一网关，会导致无法下掉老旧接口\n      2. 客户端到微服务强耦合\n      3. 多次请求，客户端聚合数据，工作量大，延迟高（影响客户端交付速度）\n      4. 把对接复杂度聚焦于端\n      5. 适配复杂度下移到微服务本身了\n   2. 解决方案app-interface（BFF）\n      1. 胶水层负责组装数据\n      2. 轻量交互，协议精简、聚合\n      3. 差异服务，数据裁剪以及聚合、针对终端定制API\n      4. 动态升级\n      5. 沟通效率提高\n   3. BFF属于 single point of failure，严重代码缺陷或者流量洪峰可能引发集群宕机\n      1. 拆分BFF，到具体模块\n      2. 升级框架中间件变困难\n      3. 跨横切面cross-cutting concerns 直接继续继续分层\n         1. 中间件功能使用api-gateway\n   4. 流量流向 端->api gateway -> bff -> microservice\n2. 微服务划分\n   1. 业务职能\n   2. DDD的限界上下文bounded context\n      1. 业务边界抽象\n      2. 抽象业务域\n3. CQRS\n   1. 命令端和查询端解耦\n   2. canal->kafka->清洗数据后将数据写入查询用库\n4. api-gateway负责统一鉴权\n5. 服务内部区分身份认证和授权（***RBAC***）\n   1. full trust\n   2. half trust\n   3. zero trust\n6. RPC鉴权\n   1. 证书\n   2. token","tags":["微服务"]},{"title":"微服务学习笔记-微服务概览","url":"/2022/06/27/微服务学习笔记-微服务概览/","content":"\n1. 微服务发展历程\n2. 单体架构\n   1. 使用模块化逻辑划分\n   2. 最终打包成大型单体\n   3. 化繁为简分而治之\n3. 微服务起源\n   1. 特点\n      1. SOA面向服务的架构模式\n      2. **小即是美**\n      3. **单一指责**\n      4. **尽可能早地创建原型**\n      5. **可移植性比效率更重要**\n   2. 运维和开发本质上对于上线是有冲突的，运维需要保持尽量的稳定，开发需要尽快的上线，对于单体架构存在更大的冲突，上线日会造成比较大的麻烦\n   3. 要具备通信的通用性\n   4. 定义\n      1. 原子服务（拆分了DB增加了系统的整体吞吐性能）\n      2. 独立进程\n      3. 隔离部署（一个物理机也可以部署多个隔离pod）（对部署多个微服务 降低crash影响）\n      4. 去中心化服务治理\n      5. 基础设施建设、复杂度高（缺点）\n   5. 不足\n      1. 增加了固有的复杂性，需要处理服务不可用和服务传递速度慢的问题\n      2. 分布式事务\n      3. 测试单一应用变复杂\n      4. 服务见的依赖，导致单一应用影响多个服务\n      5. 运维基础设施挑战高\n4. 组件服务化（多个微服务组成一个usercase）\n   1. kit:需要一套微服务基础库（框架内包）\n   2. service: 由 业务代码+kit+第三方依赖组成\n   3. RPC + message queue：轻量级通讯 \n5. 去中心化\n   1. 数据去中心化（缓存数据隔离）\n   2. 治理去中心化（避免中心热点）\n   3. 技术去中心化（不绑定语言）\n6. 基础设施自动化\n   1. cicd：gitlab +gitlab hooks +kubernetes\n   2. Testing：测试环境、单元测试、API自动化测试\n   3. 在线运行时：kubernetes，以及一系列prometheus、ELK、control panel\n7. 可用性&兼容性设计\n   1. Design For Failure\n   2. 隔离\n   3. 超时控制\n   4. 负载保护\n   5. 限流\n   6. 降级\n   7. 重试\n   8. 负载均衡\n8. 发送时保守，接受时开放【伯斯塔尔法则】尽量少传数据，接收时可以接受冗余\n","tags":["微服务"]},{"title":"goroutine与promise","url":"/2022/06/27/goroutine与promise/","content":"1. 看上去goroutine和promise有点像，但是实际上是不一样的。\n\nGolang:\n\n```go\nfunc main() {\n   go func() {\n      fmt.Println(\"aaa\")\n      time.Sleep(time.Second * 5)\n      fmt.Println(\"ccc\")\n   }()\n   fmt.Println(\"bbb\")\n   time.Sleep(time.Second * 2)\n}\n```\n\n这段代码执行的结果是 bbb aaa\n\nNodeJS:\n\n```js\nasync function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function main() {\n    new Promise(async function (resolve, reject) {\n        console.log(\"aaa\")\n\n        await sleep(1000)\n        console.log(\"ccc\")\n    })\n    console.log(\"bbb\")\n    await sleep(2000)\n    console.log(\"eee\")\n}\n\nmain()\n```\n\n执行结果是aaa bbb ccc eee\n\n执行切换上下文的节点不一样，promise回立刻执行，goroutine不会","tags":["Golang","NodeJS"]},{"title":"排序基础","url":"/2022/06/26/排序基础/","content":"1. 快速排序\n   1. 基准数左右分堆交换\n   2. 再次对左右堆进行分堆交换\n   3. 直至堆内不发生变动\n2. 冒泡排序\n   1. 交换相邻\n   2. 重复交换相邻过程\n   3. 直至再不发生变化\n3. 插入排序\n   1. 认为第一个元素有序\n   2. 遍历之后的每个元素从尾交换他们的位置，直至交换到第一个元素\n4. ","tags":["面试","排序"]},{"title":"GoLang基础","url":"/2022/06/25/GoLang基础/","content":"\n1. rune是别称类型，int32\n2. byte是别称类型，uint8\n2. 切片翻倍扩容\n2. 子切片发生扩容后不再与原数组共享内存\n2. switch不需要break\n6. http库\n   1. body只能读一次\n   2. getBody可以读多次，但是原生的http.Request是nil\n   3. header会自动转换大小写\n   4. form要先parseForm\n7.  var _ Interface = &struct{} （确保结构体实现了接口\n8. interface代表一种约束，可以作为参数传递\n9. struct作为一种实体，比较类似class的感觉，作为真正的方法的调用方，二者通过返回值串联，或者通过7约束\n10. builtin是属于全局内建\n11. error.Is会层层解包最终返回\n12. error.As转换包判断能否相等（会进行类型转换尝试）\n12. defer由下至上执行->类似栈，先进后出\n12. 闭包：函数匿名+定义他的上下文，可以访问定义范围外的变量，闭包延时绑定（最终执行的时候的变量才是延迟执行的）\n12. panic代表无可挽回，可以用recover恢复\n12. channel 缓存满了阻塞生产者，缓存空了阻塞消费者\n17. golang里面更重要的是接口的抽象和使用func传递的设计感觉\n    1. 比如设计可扩展的中间件，过滤器\n    2. 会涉及到传入类似callback的东西去处理","tags":["golang","基础"]},{"title":"网络协议复习-HTTP","url":"/2022/06/24/网络协议复习-HTTP/","content":"\n# HTTP\n\n1. 基于TCP\n2. 2.0版本对包头进行压缩\n   1. 1.1多请求串行\n   2. 2.0请求并行\n3. keep-alive 保持连接不会立刻中断tcp连接，请求复用\n\n# HTTPS\n\n1. https的通信流程是为了通过非对称加密来生成对称加密使用的参数\n2. 流程\n   1. 客户端生成随机数\n   2. 服务端返回随机数\n   3. 审核服务端证书\n   4. 审核客户端证书\n   5. 生成pre-master\n   6. 服务端+客户端+pre-master 算出对称密钥\n   7. 测试参数- c->s\n   8. 测试参数- s->c\n   9. 完成\n3. 包内包含时间戳和随机数，确保不会被重放和篡改\n4. SSL在应用层和传输层之间\n\n\n\n# QUIC\n\n1. HTTP3.0\n2. 基于udp\n3. 自定义连接机制\n4. 自定义重传机制\n5. 无阻塞的多路复用\n6. 自定义流量控制\n","tags":["HTTP","HTTPS","QUIC"]},{"title":"网络协议复习-TCP与UDP","url":"/2022/06/24/网络协议复习-TCP与UDP/","content":"\n1. TCP\n   1. 超时重试\n      1. 根据往返时间RTT计算超时重试时间-自适应重传算法\n      2. 超时一次时间加倍一次\n      3. SACK 选择应答 TCP包头增加SACK ，接收端返回三个重复的ack，发送方立刻重发丢失包\n   2. 流量控制\n      1. 滑动窗口\n         1. 避免包堆积\n         2. 接收方处理不过来时发送方不再发送\n         3. 发送方发送窗口探测数据包 调整窗口大小\n      2. 拥塞控制\n         1. TCP BBR拥塞算法，寻找最大，但不占用缓存的发送速度\n         2. 传统算法在速度达到最大值时会因为中间设备缓存问题导致时延变大\n   3. 特点\n      1. 可靠交付\n      2. 面向字节流\n      3. 拥塞控制\n      4. 有状态服务\n2. UDP\n   1. 结构简单\n   2. 不建立连接\n   3. 不做拥塞控制\n   4. 适合做广播\n   5. 应用\n      - 将能力返还给应用层，应用决定具体实现不拘泥于传统的拥塞控制\n      - DHCP、VXLAN、QUIC\n3. Socket\n   1. tcp理论上限 客户端ip x 客户端端口=2^32*2^16=2^48\n   2. 实际上收到**文件描述符**限制和**内存**限制 达不到上限\n   3. 增加接受能力方式\n      1. 多进程- fork进程\n      2. 多线程- pthread_create\n      3. IO多路复用，一个线程维护多个Socket\n         1. fd_set\n         2. select函数，轮训\n      4. IO多路复用\n         1. epoll callback通知（解决c10k）\n\n","tags":["面试","复习","网络协议"]},{"title":"面试PHP-Day1","url":"/2022/06/24/面试PHP-Day1/","content":"\n太久没面试了，记录一下找感觉的过程，和面试过程中遇到的问题\n\n## 问题\n\n1. 网络分层\n   1. OSI七层模型（由上至下 外到底）\n      1. 应用层\n      2. 表示层\n      3. 会话层\n      4. 传输层\n      5. 网络层\n      6. 数据链路层\n      7. 物理层\n   2. TCP/IP四层模型\n      1. 应用层(1.1 1.2 1.3)\n      2. 传输层 \n      3. 网络层 1.5\n      4. 网络接口层（1.6 1.7）\n2. TCP三次握手四次挥手\n   1. 三次握手（证明有来有回，连通性）\n      1. 请求（syn,自身变为syn_sent）\n      2. 应答（syn,自身从listen 变为 syn_rcvd）\n      3. 应答的应答（ack,自身变为established，对方收到后一样）\n   2. 四次挥手\n      1. a：fin(要断开) （变为FIN_WAIT_1）\n      2. b：返回ack（变为CLOSED_WAIT）\n      3. b：返回fin,ack(准备完成)，变为LAST_ACK\n      4. a：返回ack 变为 TIME_WAIT，等待2MSL（为了保证b能收到最后的ack）\n      5. TIME_WAIT这个问的我直接失忆了...太久没看这些了\n3. php-fpm 运行模式\n   1. Static 直接fork max_children\n   2. dynamic 动态fork worker（保证最小）\n   3. ondemand（初始不分配worker，最大max_children 空闲process_idle_timeout后推出）\n\n### tips\n\n答得还可以的问题或者我觉得有思路的问题就不写了\n","tags":["面试","PHP"]},{"title":"裁经Day1","url":"/2022/06/24/裁经Day1/","content":"\n## 介绍\n\n1. 仲裁院只负责经济纠纷，不负责离职证明\n2. 仲裁需要去注册地的仲裁院\n3. 离职证明需要去工作地的劳动监察大队（可以扫码直接网上申请）\n4. 海淀区有两个仲裁院（海淀仲裁院和中关村分院）\n   1. 2022.06这个时间节点，中关村分院也可以受理海淀非中关村区域的仲裁申请\n   2. 中关村分院不需要排队\n   3. 海淀分院八点之前就已经差不多排满上午的号了\n\n## 经历\n\n1. 我是去的海淀仲裁院，所以以下内容只针对海淀分院\n   1. 只需要知道公司的地址公司的名称即可\n   2. 需要带劳动合同和身份证\n   3. 第一次去只是提交申请，不需要提交证据\n   4. 身份证复印件窗口可以免费复印，但是会问你带没带，我没带小姐姐直接免费给我印了。\n   5. 填写完会给告知书，虽然上面写着5天内，但是小姐姐说是1-2周内练习\n   6. 排在我后面的大叔说去年他来的时候不需要排队直接取号就办理\n      1. 去年他总共耗时2个月左右但是因为强制执行的问题总共耗时8-9个月\n2. 早上赶了首班车地铁，浑浑噩噩一整天，六点多就到了仲裁院门口，八点半左右开始叫号，不到9点，办完了就出来了。\n","tags":["仲裁"]},{"title":"Hello World","url":"/2022/06/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]